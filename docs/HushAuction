ถ้าจะทำ “ให้เหมือนที่เขาประกาศ” ให้ยึด สเปกแบบนี้เป๊ะ: single-price, sealed-bid Dutch auction บน Ethereum โดย “ราคา (price) เป็น public แต่ “จำนวน (quantity) เป็น private” และคำนวณ clearing price (ราคากลาง) + allocation ด้วย FHE 
zama.org
+1

ด้านล่างคือ blueprint ที่ทำตามได้จริง (contract + frontend + test) และเหมาะส่ง Developer Program

4 เฟสแบบ Zama (โครงเดียวกัน)

Shield stablecoins: แปลง USDC/USDT/DAI (ERC-20) → ERC-7984 confidential token (ยอด/จำนวนโอนถูกเข้ารหัส) 
zama.org
+2
OpenZeppelin Docs
+2

Place bids (ช่วงเวลา 4 วัน): 1 bid = price (public) + quantity (private), ส่งได้หลาย bid และ cancel ได้ 
zama.org
+1

Clearing price & allocation: เติมจากราคาสูง→ต่ำ จน supply หมด, ราคาที่ทำให้ “เต็ม” คือ clearing price; เคส pro-rata ที่ราคาเท่ากับ clearing price 
zama.org
+1

Claim: รับโทเคน + refund (ขอคืนได้เป็น ERC-20 หรือ ERC-7984) 
zama.org
+1

หมายเหตุความเป็นส่วนตัว: Zama ทำให้ “quantity” เป็น private แต่ ตัวตน/ที่อยู่กระเป๋า (address) ยัง public ตามธรรมชาติของ EVM

สถาปัตยกรรมสัญญา (ให้เหมือนของจริง)
A) ShieldingWrapper (ERC-20 → ERC-7984)

ใช้ OpenZeppelin Confidential Contracts / ERC-7984 เป็นฐาน (ไม่เขียนเอง) 
OpenZeppelin Docs
+1

ฟังก์ชันหลัก: wrap(amount) / unwrap(amount) (จำนวนที่โอนเป็น encrypted handle)

B) Auction (รับ bid + escrow + cancel)

ข้อมูล bid (ต่อ 1 รายการ):

priceTick (uint32, public) ← บังคับ step 0.005 ตามสเปกเขา 
zama.org
+1

qtyEnc (euint64, private)

paidEnc (euint64, private) = qtyEnc * priceTick (คิดเป็น fixed-point)

active (bool)

ตอน bid

ผู้ใช้ส่ง qtyEnc เป็น encrypted input พร้อม proof (ตาม flow ของ FHEVM SDK)

โอน ERC-7984 เข้า Auction เป็น escrow (ฝากพักเงิน) ตาม paidEnc

เก็บ bid ไว้ และให้ cancel ได้ก่อนปิด

ตอน cancel

ทำเครื่องหมาย inactive และโอนเงิน escrow คืน (เป็น ERC-7984 → private)

C) Settlement (คำนวณ clearing + allocation ด้วย FHE)

ทำเหมือนคำอธิบาย “fill high→low” ของเขา 
zama.org
+1

แนวทางที่ “ทำได้จริงบนเชน” สำหรับเดโม:

รวม demand ต่อ priceTick เป็น totalQtyEnc[tick] = Σ qtyEnc

ทำ cumulative จาก tick สูง→ต่ำ: cumEnc += totalQtyEnc[tick]

หา tick แรกที่ cumEnc >= supply (เปรียบเทียบแบบ FHE)

request decryption เพื่อเปิดเผย แค่ clearingTick (หรือ clearing price) เป็น public ตอนจบ 
Zama Documentation
+1

คำนวณ allocation/refund:

ราคา > clearing: ได้เต็ม qty + refund ส่วนต่าง (overpay)

ราคา = clearing: ได้ pro-rata ถ้าเกิน supply ที่เหลือ

ราคา < clearing: refund เต็ม

จุดสำคัญ: การ “เปิดผล” ต้องใช้ asynchronous decryption (ถอดรหัสแบบ async) ผ่าน requestDecryption + callback ตรวจลายเซ็น (checkSignatures) 
Zama Documentation
+2
Zama Documentation
+2

D) Claim

ผู้ใช้มากด claim ทีละคน → สัญญา request decrypt เฉพาะ allocation/refund ของคนนั้น → callback แล้วค่อย

โอน token ที่ขาย (ERC-20 ปกติ)

คืนเงิน (เลือก ERC-20 หรือ ERC-7984)

Frontend ที่ต้องมี (ให้ดู “โปรดักชัน”)

หน้า Shield: wrap/unwrap + โชว์ยอด (ยอดเป็น encrypted → ต้องใช้ user decrypt ใน UI) 
Zama Documentation
+1

หน้า Bids: สร้าง encrypted quantity ด้วย @fhevm-sdk/core, ส่ง bid/cancel, รายการ bids ของตัวเอง (แสดง quantity ด้วย user decrypt เฉพาะของตัวเอง)

หน้า Settle/Status: โชว์ timeline + สถานะ “bidding / settling / claimable”

หน้า Claim: claim token + refund

ถ้าจะ “เหมือนสุด” เพิ่ม 2 อย่างนี้

Fixed-price sale หลังประมูล ที่ clearing price และ cap ต่อคน (เช่น $10k) — ในโพสต์เขาแบ่ง 8% auction + 2% fixed-price 
zama.org
+1

บังคับ price เป็น tick 0.005 (fixed-point) ตามที่เขาระบุ 
zama.org
+1

ของที่คุณควรทำก่อน (ลำดับงานที่ไม่หลงทาง)

ตั้งรูปแบบราคา: priceTick = จำนวน “$0.005” ต่อ tick (เก็บเป็น integer)

ทำ Shield wrapper (ERC-7984) ให้เรียบร้อยก่อน 
OpenZeppelin Docs

ทำ bid/cancel + escrow ให้ครบ

ทำ settle แบบ “รองรับ bid ไม่เยอะ” ให้เดโมผ่านก่อน

ทำ claim ทีละคน (decrypt ต่อผู้ใช้) ให้รัน end-to-end ได้

เขียน tests ครอบ 3 outcome + pro-rata + cancel + claim

